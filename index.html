<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Toddler Interactive Screen</title>
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js CDN for sound generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Custom styles for the app */
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent scrolling */
            cursor: none; /* Hide default cursor when locked */
            touch-action: none; /* Prevent browser default touch actions like pull-to-refresh */
        }

        /* The main overlay that locks the screen */
        #lock-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            /* Initial subtle gradient, will be animated */
            background: radial-gradient(circle at center, #1a1a1a, #000000);
            background-size: 200% 200%; /* Larger background for animation */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 9999; /* Ensure it's on top of everything */
            transition: background 0.5s ease-in-out; /* Smooth background transitions for gradients */
            cursor: none; /* Hide cursor when locked */
            animation: background-flow 30s linear infinite alternate; /* Continuous, subtle background animation */
        }

        /* Keyframes for the continuous background flow */
        @keyframes background-flow {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }

        /* Styles for the dynamically generated visual elements */
        .visual-element {
            position: absolute;
            opacity: 0;
            transform: scale(0.1) rotate(0deg); /* Initial state with rotation */
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55); /* Bouncy transition for appearance */
            pointer-events: none; /* Ensure these elements don't block events */
            user-select: none; /* Prevent text selection */
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            will-change: transform, opacity; /* Optimize for animation */
        }

        /* Class to make the visual element appear */
        .visual-element.show {
            opacity: 1;
            transform: scale(1) rotate(var(--random-rotation, 0deg)); /* Use custom property for random rotation */
        }

        /* Class to fade out and remove the visual element, with added drift */
        .visual-element.hide {
            opacity: 0;
            transform: scale(1.5) rotate(var(--random-rotation, 0deg)) translate(var(--drift-x, 0px), var(--drift-y, 0px)); /* Slightly grow and drift as it fades */
            transition: all 0.7s ease-out; /* Longer transition for fade and drift */
        }

        /* Heartbeat animation for parent mode instruction */
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
            100% { transform: scale(1); opacity: 1; }
        }

        .animate-heartbeat {
            animation: pulse 1.5s infinite;
        }

        /* Base styles for all parent panels */
        .parent-panel {
            position: absolute; /* Position relative to parent, not viewport */
            top: 50%; /* Center vertically */
            left: 50%; /* Center horizontally */
            transform: translate(-50%, -50%); /* Adjust for element's own size */
            background-color: rgba(51, 51, 51, 0.9); /* Dark gray, slightly transparent */
            padding: 2rem; /* More padding for centered look */
            display: flex;
            flex-direction: column; /* Stack buttons vertically */
            align-items: center; /* Center buttons horizontally within panel */
            gap: 1rem; /* More space between stacked buttons */
            z-index: 10000; /* Ensure it's on top */
            border-radius: 1rem; /* Rounded corners for the whole panel */
            box-shadow: 0 5px 20px rgba(0,0,0,0.5); /* Stronger shadow */
            opacity: 0; /* Start hidden */
            pointer-events: none; /* Do not block events when hidden */
            transition: opacity 0.3s ease-out; /* Fade in/out */
        }

        .parent-panel.show {
            opacity: 1; /* Fade in */
            pointer-events: auto; /* Allow interaction when shown */
        }

        /* Specific styling for the main parent control panel (no background color) */
        #parent-control-panel {
            background-color: transparent; /* Make background transparent */
            box-shadow: none; /* Remove shadow if background is transparent */
            padding: 0; /* Remove padding if background is transparent */
            gap: 0.75rem; /* Slightly smaller gap for main menu */
        }

        /* Styling for buttons within all parent panels */
        .parent-panel button {
            @apply flex-grow md:flex-grow-0 px-4 py-2 rounded-lg font-bold shadow-md transition-all duration-200;
            min-width: 180px; /* Ensure buttons have a minimum width for readability */
            font-size: 1.5rem; /* Make text larger */
            background-color: transparent; /* No background color */
            border: none; /* No border */
            color: #D14081; /* Vibrant purple text */
            box-shadow: none; /* No shadow */
            padding: 0.5rem 1rem; /* Adjust padding for text-like buttons */
        }

        .parent-panel button:hover {
            transform: none; /* No translateY effect */
            box-shadow: none; /* No shadow on hover */
            background-color: transparent; /* Still no background on hover */
            border: none; /* Still no border on hover */
            color: #FFD166; /* Yellow text on hover */
        }

        /* Specific styling for "Back to Parent Menu" button (at bottom of sub-panels) */
        .back-to-parent-menu-btn { /* Renamed for clarity */
            background-color: transparent !important;
            border: none !important;
            color: #06D6A0 !important; /* Green text */
            box-shadow: none !important;
        }

        .back-to-parent-menu-btn:hover {
            background-color: transparent !important;
            border: none !important;
            color: #FFD166 !important;
            transform: none !important;
            box-shadow: none !important;
        }

        /* Top-left back button specific styling (for active lesson screen) */
        #back-to-parent-menu-from-lesson {
            position: absolute;
            top: 1rem;
            left: 1rem;
            z-index: 10001; /* Ensure it's above other panel elements */
            font-size: 1.2rem; /* Slightly smaller than main buttons */
            color: #06D6A0; /* Green text */
            background-color: transparent;
            border: none;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 0.5rem;
            transition: color 0.2s ease-in-out;
        }

        #back-to-parent-menu-from-lesson:hover {
            color: #FFD166; /* Yellow text on hover */
        }

        /* Canvas for tracing */
        #tracing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* Below visual-feedback-area, above background */
            pointer-events: none; /* Initially don't block events */
        }
    </style>
</head>
<body class="locked">
    <!-- The main overlay that covers the entire screen when locked -->
    <div id="lock-overlay" class="rounded-lg">
        <!-- Initial messages (shown first) -->
        <h1 id="main-title" class="text-white text-5xl md:text-7xl font-extrabold mb-8 text-center animate-pulse">
            Ready to Play!
        </h1>
        <p id="main-message" class="text-white text-xl md:text-2xl text-center">
            Tap or swipe the screen!
        </p>
        <!-- Parent Mode Activation Instruction (initially hidden) -->
        <p id="parent-mode-instruction" class="text-white text-xl md:text-2xl text-center animate-heartbeat hidden">
            Tap all four corners clockwise to activate Parent Mode
        </p>
        <!-- This area will be dynamically populated with visual feedback -->
        <div id="visual-feedback-area"></div>
        <!-- Canvas for tracing -->
        <canvas id="tracing-canvas"></canvas>

        <!-- New: Back to Parent Menu button visible during active lesson play -->
        <button id="back-to-parent-menu-from-lesson" class="top-left-back-button hidden">Back to Parent Menu</button>
    </div>

    <!-- Main Parent Control Panel -->
    <div id="parent-control-panel" class="parent-panel hidden">
        <button id="color-recognition-btn">Color Recognition</button>
        <button id="shape-recognition-btn">Shape Recognition</button>
        <button id="letter-number-btn">Letter/Number Introduction</button>
        <button id="freeplay-btn">Back to Freeplay</button>
    </div>

    <!-- Lesson Specific Panels (initially hidden) -->
    <div id="color-lesson-panel" class="parent-panel hidden">
        <button id="color-primary-btn">Primary Colors</button>
        <button id="color-all-btn">All Colors</button>
        <button class="back-to-parent-menu-btn" id="color-back-btn">Back to Parent Menu</button>
    </div>

    <div id="shape-lesson-panel" class="parent-panel hidden">
        <button id="shape-basic-btn">Basic Shapes</button>
        <button id="shape-advanced-btn">Advanced Shapes</button>
        <button class="back-to-parent-menu-btn" id="shape-back-btn">Back to Parent Menu</button>
    </div>

    <div id="letter-number-lesson-panel" class="parent-panel hidden">
        <button id="letter-az-btn">Letters (A-Z)</button>
        <button id="number-09-btn">Numbers (0-9)</button>
        <button class="back-to-parent-menu-btn" id="letter-number-back-btn">Back to Parent Menu</button>
    </div>

    <script>
        // Get references to the main elements
        const lockOverlay = document.getElementById('lock-overlay');
        const visualFeedbackArea = document.getElementById('visual-feedback-area');
        const mainTitle = document.getElementById('main-title');
        const mainMessage = document.getElementById('main-message');
        const parentModeInstruction = document.getElementById('parent-mode-instruction');
        const parentControlPanel = document.getElementById('parent-control-panel');
        const tracingCanvas = document.getElementById('tracing-canvas');
        const ctx = tracingCanvas.getContext('2d'); // Get 2D rendering context

        // Get references to parent mode buttons
        const colorBtn = document.getElementById('color-recognition-btn');
        const shapeBtn = document.getElementById('shape-recognition-btn');
        const letterNumberBtn = document.getElementById('letter-number-btn');
        const freeplayBtn = document.getElementById('freeplay-btn');

        // Get references to lesson specific panels and their buttons
        const colorLessonPanel = document.getElementById('color-lesson-panel');
        const colorPrimaryBtn = document.getElementById('color-primary-btn');
        const colorAllBtn = document.getElementById('color-all-btn');
        const colorBackBtn = document.getElementById('color-back-btn');

        const shapeLessonPanel = document.getElementById('shape-lesson-panel');
        const shapeBasicBtn = document.getElementById('shape-basic-btn');
        const shapeAdvancedBtn = document.getElementById('shape-advanced-btn');
        const shapeBackBtn = document.getElementById('shape-back-btn');

        const letterNumberLessonPanel = document.getElementById('letter-number-lesson-panel');
        const letterAZBtn = document.getElementById('letter-az-btn');
        const number09Btn = document.getElementById('number-09-btn');
        const letterNumberBackBtn = document.getElementById('letter-number-back-btn');

        // New button for returning to parent menu from active lesson
        const backToParentMenuFromLessonBtn = document.getElementById('back-to-parent-menu-from-lesson');

        const body = document.body;

        // State variables
        let isLocked = true;
        let isTouching = false;
        let hasInteracted = false; // Tracks if toddler has started interacting
        let isParentModeActive = false; // New flag for parent mode
        let currentLessonMode = 'freeplay'; // Default lesson mode
        let audioContextStarted = false; // Flag to track if Tone.js audio context has started
        let isTracingModeActive = false; // New flag for tracing lessons

        // Parent Mode Activation Sequence
        const parentModeSequence = ['top-left', 'top-right', 'bottom-right', 'bottom-left'];
        let currentSequenceIndex = 0;
        let lastTapTime = 0;
        const tapTimeout = 2000; // 2 seconds to complete next tap in sequence

        // Timer for parent mode instruction visibility
        let parentInstructionTimer;
        const initialMessageDuration = 7000; // 7 seconds for initial "Ready to Play" messages
        const instructionShowDuration = 7000; // 7 seconds for parent mode instruction
        const instructionHideDuration = 30000; // 30 seconds for parent mode instruction

        // Initialize Tone.js Synth for sound feedback
        const synth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "sine" },
            envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.3 },
            volume: -20
        }).toDestination();

        // Array of vibrant colors for visual feedback and background gradients
        const colors = [
            '#FF6B6B', '#FFD166', '#06D6A0', '#118AB2', '#073B4C',
            '#FF9F1C', '#2EC4B6', '#E71D36', '#F7B801', '#A9F0D1',
            '#C70039', '#FFC300', '#DAF7A6', '#FF5733', '#C70039',
            '#6A0572', '#AB83A1', '#8E292E', '#D14081', '#F08A5D'
        ];

        // Specific colors for 'color-recognition' lesson
        const lessonColorsPrimary = ['#FF0000', '#0000FF', '#00FF00']; // Red, Blue, Green
        const lessonColorsAll = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF', '#FF6B6B', '#FFD166', '#06D6A0', '#118AB2']; // Expanded set

        // Specific shapes for 'shape-recognition' lesson
        const lessonShapesBasic = ['‚óè', '‚ñ†', '‚ñ≤']; // Circle, Square, Triangle
        const lessonShapesAdvanced = ['‚òÖ', '‚óÜ', '‚ù§', '‚≠ê']; // Star, Diamond, Heart, Sparkle Star

        // Characters for 'letter-number-introduction' lesson (A-Z, 0-9)
        const lessonLetters = [
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'
        ];
        const lessonNumbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];

        // All characters/emojis for freeplay
        const characters = [
            ...lessonLetters, ...lessonNumbers,
            '‚≠ê', 'üåà', 'üéâ', 'üéà', '‚ú®', 'üöÄ', 'üíñ', 'üí°', 'üéµ', 'üå∏', 'üå≥', '‚òÄÔ∏è', 'üåô', '‚òÅÔ∏è'
        ];

        // Array of musical notes for sound feedback
        const notes = ['C4', 'D4', 'E4', 'G4', 'A4', 'C5', 'D5', 'E5'];

        // Function to get a random element from an array
        function getRandomElement(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        // Function to hide the initial messages (Ready to Play / Tap or swipe)
        function hideInitialMessages() {
            if (mainTitle) mainTitle.classList.add('hidden');
            if (mainMessage) mainMessage.classList.add('hidden');
        }

        // Function to show the initial messages
        function showInitialMessages() {
            if (mainTitle) mainTitle.classList.remove('hidden');
            if (mainMessage) mainMessage.classList.remove('hidden');
        }

        // Function to manage parent mode instruction visibility
        function startParentInstructionTimer() {
            // Clear any existing timer
            if (parentInstructionTimer) clearInterval(parentInstructionTimer);

            // Only start instruction timer if in freeplay mode
            if (currentLessonMode === 'freeplay') {
                function showAndHideParentInstruction() {
                    parentModeInstruction.classList.remove('hidden');
                    parentModeInstruction.classList.add('animate-heartbeat'); // Ensure animation is active
                    setTimeout(() => {
                        parentModeInstruction.classList.add('hidden');
                        parentModeInstruction.classList.remove('animate-heartbeat'); // Remove animation when hidden
                    }, instructionShowDuration);
                }

                // Show immediately, then set interval for repeated show/hide
                showAndHideParentInstruction();
                parentInstructionTimer = setInterval(showAndHideParentInstruction, instructionHideDuration + instructionShowDuration);
            } else {
                // If not in freeplay, ensure instruction is hidden
                parentModeInstruction.classList.add('hidden');
                parentModeInstruction.classList.remove('animate-heartbeat');
            }
        }

        function stopParentInstructionTimer() {
            if (parentInstructionTimer) {
                clearInterval(parentInstructionTimer);
                parentInstructionTimer = null;
            }
            parentModeInstruction.classList.add('hidden');
            parentModeInstruction.classList.remove('animate-heartbeat');
        }

        // Function to get the corner based on coordinates
        function getCorner(x, y) {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const cornerThreshold = 0.2; // 20% of screen width/height for corner detection

            if (x < width * cornerThreshold && y < height * cornerThreshold) {
                return 'top-left';
            } else if (x > width * (1 - cornerThreshold) && y < height * cornerThreshold) {
                return 'top-right';
            } else if (x > width * (1 - cornerThreshold) && y > height * (1 - cornerThreshold)) {
                return 'bottom-right';
            } else if (x < width * cornerThreshold && y > height * (1 - cornerThreshold)) {
                return 'bottom-left';
            }
            return null; // Not in a defined corner
        }

        // Function to hide all lesson panels
        function hideAllLessonPanels() {
            const panels = [parentControlPanel, colorLessonPanel, shapeLessonPanel, letterNumberLessonPanel];
            panels.forEach(panel => {
                panel.classList.remove('show');
                panel.classList.add('hidden');
            });
        }

        // Function to show a specific lesson panel
        function showLessonPanel(panelElement) {
            hideAllLessonPanels(); // Hide all others first
            panelElement.classList.remove('hidden');
            setTimeout(() => {
                panelElement.classList.add('show');
            }, 10);
        }

        // Function to activate parent mode (show main parent menu)
        function activateParentMode() {
            isParentModeActive = true;
            stopParentInstructionTimer(); // Stop instruction timer when entering parent mode
            parentModeInstruction.classList.add('hidden'); // Ensure it's hidden
            hideInitialMessages(); // Ensure initial messages are hidden if parent mode is activated early

            showLessonPanel(parentControlPanel); // Show the main parent control panel

            console.log("Parent Mode Activated!");
            // Change background to indicate parent mode
            lockOverlay.style.background = `radial-gradient(circle at center, #333333, #111111)`; // Subtle gray
            lockOverlay.style.animation = 'none'; // Stop background flow animation
            lockOverlay.style.backgroundSize = 'cover'; // Reset background size for static color

            // Hide the "Back to Parent Menu" button that appears during active lesson play
            backToParentMenuFromLessonBtn.classList.add('hidden');
        }

        // Function to deactivate parent mode (return to toddler freeplay or active lesson)
        function deactivateParentMode() {
            isParentModeActive = false;
            currentSequenceIndex = 0; // Reset sequence
            lastTapTime = 0; // Reset tap time

            hideAllLessonPanels(); // Hide all parent/lesson panels

            // Reset tracing mode
            isTracingModeActive = false;
            clearCanvas(); // Clear anything drawn on the canvas

            // Show the "Back to Parent Menu" button if we are entering a lesson mode (not freeplay)
            if (currentLessonMode !== 'freeplay') {
                backToParentMenuFromLessonBtn.classList.remove('hidden');
            } else {
                backToParentMenuFromLessonBtn.classList.add('hidden');
            }

            // Start parent instruction timer ONLY if in freeplay mode
            if (currentLessonMode === 'freeplay') {
                startParentInstructionTimer();
            } else {
                stopParentInstructionTimer(); // Ensure it's stopped if not in freeplay
            }

            // Reset background to dynamic
            lockOverlay.style.animation = 'background-flow 30s linear infinite alternate';
            lockOverlay.style.backgroundSize = '200% 200%';
            changeBackgroundGradient(); // Set an initial dynamic gradient
            hasInteracted = false; // Reset interaction flag so initial messages can show again on re-lock
        }

        // New function to return to parent menu from an active lesson display
        function returnToParentMenuFromLesson() {
            isParentModeActive = true; // Re-activate parent mode
            isTracingModeActive = false; // Ensure tracing is off
            clearCanvas(); // Clear canvas
            stopParentInstructionTimer(); // Ensure instruction timer is stopped

            // Hide the "Back to Parent Menu" button from lesson display
            backToParentMenuFromLessonBtn.classList.add('hidden');

            showLessonPanel(parentControlPanel); // Show the main parent control panel

            // Set background to parent mode theme
            lockOverlay.style.background = `radial-gradient(circle at center, #333333, #111111)`;
            lockOverlay.style.animation = 'none';
            lockOverlay.style.backgroundSize = 'cover';
            console.log("Returned to Parent Menu from Lesson.");
        }


        // --- Canvas Drawing Functions for Tracing ---
        function clearCanvas() {
            ctx.clearRect(0, 0, tracingCanvas.width, tracingCanvas.height);
            tracingCanvas.style.pointerEvents = 'none'; // Disable pointer events on canvas when not tracing
        }

        function resizeCanvas() {
            tracingCanvas.width = window.innerWidth;
            tracingCanvas.height = window.innerHeight;
            // Redraw content if needed after resize (important for tracing)
            if (isTracingModeActive && currentTargetToTrace) {
                drawOutline(currentTargetToTrace.type, currentTargetToTrace.content);
            }
        }

        let currentTargetToTrace = null; // Stores { type: 'shape'/'letter', content: '‚óè'/'A' }

        function drawOutline(type, content) {
            clearCanvas();
            tracingCanvas.style.pointerEvents = 'auto'; // Enable pointer events on canvas for tracing

            ctx.lineWidth = 5;
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)'; // Faint white outline
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // Center the drawing
            const centerX = tracingCanvas.width / 2;
            const centerY = tracingCanvas.height / 2;
            const size = Math.min(tracingCanvas.width, tracingCanvas.height) * 0.4; // Responsive size

            ctx.save(); // Save current context state
            ctx.translate(centerX, centerY); // Move origin to center

            if (type === 'shape') {
                ctx.beginPath();
                if (content === '‚óè') { // Circle
                    ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
                } else if (content === '‚ñ†') { // Square
                    ctx.rect(-size / 2, -size / 2, size, size);
                } else if (content === '‚ñ≤') { // Triangle
                    ctx.moveTo(0, -size / 2);
                    ctx.lineTo(size / 2, size / 2);
                    ctx.lineTo(-size / 2, size / 2);
                    ctx.closePath();
                } else if (content === '‚òÖ') { // Star (simplified)
                    const outerRadius = size / 2;
                    const innerRadius = outerRadius / 2.5;
                    let rot = Math.PI / 2 * 3;
                    let x = 0;
                    let y = 0;
                    const step = Math.PI / 5;

                    ctx.moveTo(0, -outerRadius);
                    for (let i = 0; i < 5; i++) {
                        x = outerRadius * Math.cos(rot);
                        y = outerRadius * Math.sin(rot);
                        ctx.lineTo(x, y);
                        rot += step;

                        x = innerRadius * Math.cos(rot);
                        y = innerRadius * Math.sin(rot);
                        ctx.lineTo(x, y);
                        rot += step;
                    }
                    ctx.closePath();
                } else if (content === '‚óÜ') { // Diamond
                    ctx.moveTo(0, -size / 2);
                    ctx.lineTo(size / 2, 0);
                    ctx.lineTo(0, size / 2);
                    ctx.lineTo(-size / 2, 0);
                    ctx.closePath();
                } else if (content === '‚ù§') { // Heart (simplified)
                    ctx.moveTo(0, size * 0.2);
                    ctx.bezierCurveTo(size * 0.5, -size * 0.5, size, size * 0.1, 0, size * 0.8);
                    ctx.bezierCurveTo(-size, size * 0.1, -size * 0.5, -size * 0.5, 0, size * 0.2);
                    ctx.closePath();
                } else if (content === '‚≠ê') { // Another star variation if needed, or fallback
                    const outerRadius = size / 2;
                    const innerRadius = outerRadius * 0.4; // Adjust for a different star look
                    let rot = Math.PI / 2 * 3;
                    let x = 0;
                    let y = 0;
                    const step = Math.PI / 5;

                    ctx.moveTo(0, -outerRadius);
                    for (let i = 0; i < 5; i++) {
                        x = outerRadius * Math.cos(rot);
                        y = outerRadius * Math.sin(rot);
                        ctx.lineTo(x, y);
                        rot += step;

                        x = innerRadius * Math.cos(rot);
                        y = innerRadius * Math.sin(rot);
                        ctx.lineTo(x, y);
                        rot += step;
                    }
                    ctx.closePath();
                }
                ctx.stroke();
            } else if (type === 'letter' || type === 'number') {
                ctx.font = `${size * 0.8}px 'Inter', sans-serif`; // Adjust font size for responsiveness
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.strokeText(content, 0, 0); // Draw text outline
            }
            ctx.restore(); // Restore context state
        }

        // --- Tracing Interaction Logic ---
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;

        function startDrawing(e) {
            if (!isLocked || !isTracingModeActive) return;
            isDrawing = true;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            [lastX, lastY] = [clientX, clientY];
            // Start a new path for each new stroke
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
            ctx.lineWidth = 20; // Thickness of the trace line
            ctx.strokeStyle = getRandomElement(colors); // Random vibrant color for the trace
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
        }

        function draw(e) {
            if (!isDrawing || !isLocked || !isTracingModeActive) return;
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            ctx.lineTo(clientX, clientY);
            ctx.stroke();
            [lastX, lastY] = [clientX, clientY];

            // Simple completion check: if a certain amount of drawing has occurred,
            // or if the user lifts their finger after a substantial drag.
            // For now, let's just redraw a new outline after a short continuous drag.
            // A more robust completion check (e.g., path coverage) would be complex.
        }

        function stopDrawing() {
            if (!isDrawing) return;
            isDrawing = false;
            // After a stroke, briefly fill the outline for completion feedback
            if (currentTargetToTrace) {
                ctx.save();
                ctx.translate(tracingCanvas.width / 2, tracingCanvas.height / 2);
                ctx.fillStyle = getRandomElement(colors); // Fill with a vibrant color
                if (currentTargetToTrace.type === 'shape') {
                    // Redraw the shape and fill it
                    ctx.beginPath();
                    const size = Math.min(tracingCanvas.width, tracingCanvas.height) * 0.4;
                    if (currentTargetToTrace.content === '‚óè') { // Circle
                        ctx.arc(0, 0, size / 2, 0, Math.PI * 2);
                    } else if (currentTargetToTrace.content === '‚ñ†') { // Square
                        ctx.rect(-size / 2, -size / 2, size, size);
                    } else if (currentTargetToTrace.content === '‚ñ≤') { // Triangle
                        ctx.moveTo(0, -size / 2);
                        ctx.lineTo(size / 2, size / 2);
                        ctx.lineTo(-size / 2, size / 2);
                        ctx.closePath();
                    } else if (currentTargetToTrace.content === '‚òÖ') { // Star (simplified)
                        const outerRadius = size / 2;
                        const innerRadius = outerRadius / 2.5;
                        let rot = Math.PI / 2 * 3;
                        let x = 0;
                        let y = 0;
                        const step = Math.PI / 5;

                        ctx.moveTo(0, -outerRadius);
                        for (let i = 0; i < 5; i++) {
                            x = outerRadius * Math.cos(rot);
                            y = outerRadius * Math.sin(rot);
                            ctx.lineTo(x, y);
                            rot += step;

                            x = innerRadius * Math.cos(rot);
                            y = innerRadius * Math.sin(rot);
                            ctx.lineTo(x, y);
                            rot += step;
                        }
                        ctx.closePath();
                    } else if (currentTargetToTrace.content === '‚óÜ') { // Diamond
                        ctx.moveTo(0, -size / 2);
                        ctx.lineTo(size / 2, 0);
                        ctx.lineTo(0, size / 2);
                        ctx.lineTo(-size / 2, 0);
                        ctx.closePath();
                    } else if (currentTargetToTrace.content === '‚ù§') { // Heart (simplified)
                        ctx.moveTo(0, size * 0.2);
                        ctx.bezierCurveTo(size * 0.5, -size * 0.5, size, size * 0.1, 0, size * 0.8);
                        ctx.bezierCurveTo(-size, size * 0.1, -size * 0.5, -size * 0.5, 0, size * 0.2);
                        ctx.closePath();
                    } else if (currentTargetToTrace.content === '‚≠ê') { // Another star variation if needed, or fallback
                        const outerRadius = size / 2;
                        const innerRadius = outerRadius * 0.4; // Adjust for a different star look
                        let rot = Math.PI / 2 * 3;
                        let x = 0;
                        let y = 0;
                        const step = Math.PI / 5;

                        ctx.moveTo(0, -outerRadius);
                        for (let i = 0; i < 5; i++) {
                            x = outerRadius * Math.cos(rot);
                            y = outerRadius * Math.sin(rot);
                            ctx.lineTo(x, y);
                            rot += step;

                            x = innerRadius * Math.cos(rot);
                            y = innerRadius * Math.sin(rot);
                            ctx.lineTo(x, y);
                            rot += step;
                        }
                        ctx.closePath();
                    }
                    ctx.fill(); // Fill the shape
                } else if (currentTargetToTrace.type === 'letter' || currentTargetToTrace.type === 'number') {
                    const size = Math.min(tracingCanvas.width, tracingCanvas.height) * 0.4;
                    ctx.font = `${size * 0.8}px 'Inter', sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(currentTargetToTrace.content, 0, 0); // Fill the text
                }
                ctx.restore();

                // Play a completion sound (if sounds were enabled)
                // synth.triggerAttackRelease('C6', '8n'); // Example high note for completion

                // After a short delay, draw a new tracing target
                setTimeout(() => {
                    startNewTracingTarget();
                }, 700); // Short delay for visual feedback
            }
        }

        // Function to start a new tracing target based on currentLessonMode
        function startNewTracingTarget() {
            let targetContent = '';
            let targetType = '';

            if (currentLessonMode === 'shape-basic') {
                targetContent = getRandomElement(lessonShapesBasic);
                targetType = 'shape';
            } else if (currentLessonMode === 'shape-advanced') {
                targetContent = getRandomElement(lessonShapesAdvanced);
                targetType = 'shape';
            } else if (currentLessonMode === 'letter-az') {
                targetContent = getRandomElement(lessonLetters);
                targetType = 'letter';
            } else if (currentLessonMode === 'number-09') {
                targetContent = getRandomElement(lessonNumbers);
                targetType = 'number';
            }

            if (targetContent) {
                currentTargetToTrace = { type: targetType, content: targetContent };
                drawOutline(targetType, targetContent);
            } else {
                clearCanvas(); // Clear canvas if no tracing target is set
            }
        }


        // Function to generate and display visual feedback
        async function generateVisualFeedback(x, y, type, content = '') {
            // Ensure audio context is started on first interaction
            if (!audioContextStarted) {
                await Tone.start();
                audioContextStarted = true;
                console.log("AudioContext started:", Tone.context.state);
            }

            if (!isLocked || isParentModeActive) return; // Only generate feedback when locked AND not in parent mode
            if (isTracingModeActive) return; // Do not generate pop-ups if in tracing mode

            // Hide initial messages on first interaction
            if (!hasInteracted) {
                hideInitialMessages();
                // Ensure parent mode instruction starts its cycle only after initial messages are gone
                // This call is now conditional on currentLessonMode === 'freeplay'
                if (currentLessonMode === 'freeplay') {
                    startParentInstructionTimer();
                }
                hasInteracted = true;
            }

            const visualElement = document.createElement('div');
            visualElement.classList.add('visual-element');
            visualElement.style.left = `${x}px`;
            visualElement.style.top = `${y}px`;

            const randomRotation = Math.random() * 360 - 180;
            visualElement.style.setProperty('--random-rotation', `${randomRotation}deg`);

            const driftX = (Math.random() - 0.5) * 100;
            const driftY = (Math.random() - 0.5) * 100;
            visualElement.style.setProperty('--drift-x', `${driftX}px`);
            visualElement.style.setProperty('--drift-y', `${driftY}px`);

            // --- Lesson-specific content generation ---
            let elementContent = '';
            let elementColor = getRandomElement(colors); // Default random color

            if (type === 'tap') {
                if (currentLessonMode === 'color-primary') {
                    elementColor = getRandomElement(lessonColorsPrimary);
                    elementContent = getRandomElement(lessonShapesBasic); // Use basic shapes for color lesson
                    visualElement.style.fontSize = `${Math.random() * 60 + 40}px`;
                } else if (currentLessonMode === 'color-all') {
                    elementColor = getRandomElement(lessonColorsAll);
                    elementContent = getRandomElement(lessonShapesBasic); // Use basic shapes for color lesson
                    visualElement.style.fontSize = `${Math.random() * 60 + 40}px`;
                } else if (currentLessonMode === 'freeplay') { // Only freeplay generates random characters/emojis
                    let sourceArray = characters;
                    if (typeof characters === 'undefined' || !Array.isArray(characters) || characters.length === 0) {
                        console.warn("Characters array is undefined, not an array, or empty. Falling back to default.");
                        sourceArray = ['?', '!', '@']; // Fallback content
                    }
                    elementContent = getRandomElement(sourceArray);
                    elementColor = getRandomElement(colors); // Random color
                    visualElement.style.fontSize = `${Math.random() * 60 + 40}px`;
                }
                // Tracing modes (shape-basic, shape-advanced, letter-az, number-09) will not generate pop-ups here
                // They will handle their own visual feedback on the canvas
            } else if (type === 'swipe') {
                if (currentLessonMode === 'freeplay' || currentLessonMode.startsWith('color-')) { // Swipes only generate pop-ups in freeplay or color modes
                    elementContent = getRandomElement(['‚ú®', 'ÔøΩ', 'üåà', 'üåü', 'üíß', 'üí´', 'üíñ', 'üí°']);
                    elementColor = getRandomElement(colors); // Random color for swipe effects
                    visualElement.style.fontSize = `${Math.random() * 30 + 20}px`;
                } else {
                    return; // Don't generate swipe effects in tracing modes
                }
            }

            if (!elementContent) return; // Don't append if no content determined (e.g., in tracing mode)

            visualElement.textContent = elementContent;
            visualElement.style.color = elementColor;

            visualFeedbackArea.appendChild(visualElement);

            setTimeout(() => {
                visualElement.classList.add('show');
            }, 10);

            synth.triggerAttackRelease(getRandomElement(notes), '8n');

            setTimeout(() => {
                visualElement.classList.remove('show');
                visualElement.classList.add('hide');
                visualElement.addEventListener('transitionend', () => {
                    visualElement.remove();
                });
            }, 700);
        }

        // Function to change the background to a random radial gradient (on tap/key)
        function changeBackgroundGradient() {
            if (!isLocked || isParentModeActive || isTracingModeActive) return; // Only change background when locked, not in parent mode, and not tracing
            const color1 = getRandomElement(colors);
            const color2 = getRandomElement(colors);
            lockOverlay.style.background = `radial-gradient(circle at center, ${color1}, ${color2})`;
            lockOverlay.style.backgroundSize = '200% 200%';
        }

        // Event listener for keydown events (for physical keyboards/hybrid devices)
        async function handleKeyDown(event) {
            // Ensure audio context is started on first interaction
            if (!audioContextStarted) {
                await Tone.start();
                audioContextStarted = true;
                console.log("AudioContext started:", Tone.context.state);
            }

            if (isLocked) {
                event.preventDefault();

                // Check for unlock combination: Ctrl + Shift + L
                if (event.ctrlKey && event.shiftKey && event.key === 'L') {
                    unlockScreen();
                } else if (!isParentModeActive && !isTracingModeActive) { // Only generate toddler feedback if not in parent mode or tracing
                    const x = Math.random() * window.innerWidth;
                    const y = Math.random() * window.innerHeight;
                    generateVisualFeedback(x, y, 'tap', event.key.toUpperCase());
                    changeBackgroundGradient();
                }
            }
        }

        // Event listener for touchstart (for initial tap)
        async function handleTouchStart(event) {
            // Ensure audio context is started on first interaction
            if (!audioContextStarted) {
                await Tone.start();
                audioContextStarted = true;
                console.log("AudioContext started:", Tone.context.state);
            }

            if (isLocked) {
                event.preventDefault(); // Prevent default touch actions like scrolling/zooming/selection
                isTouching = true;

                const touch = event.touches ? event.touches[0] : event; // Handle both touch and click events
                const tappedCorner = getCorner(touch.clientX, touch.clientY);
                const currentTime = Date.now();

                // Parent Mode Activation Logic
                // Only check sequence if not already in parent mode and tapped a corner
                // Also, ensure we are not tapping on a button within a parent panel
                const targetIsButton = event.target.tagName === 'BUTTON';
                if (!isParentModeActive && tappedCorner && !targetIsButton) {
                    if (currentTime - lastTapTime > tapTimeout) {
                        currentSequenceIndex = 0; // Reset sequence if too much time passed
                    }

                    if (tappedCorner === parentModeSequence[currentSequenceIndex]) {
                        currentSequenceIndex++;
                        if (currentSequenceIndex === parentModeSequence.length) {
                            activateParentMode();
                            currentSequenceIndex = 0; // Reset for next time
                        }
                    } else {
                        currentSequenceIndex = 0; // Reset if wrong corner
                    }
                    lastTapTime = currentTime;
                } else if (!isParentModeActive && !targetIsButton) { // Reset sequence if tap is not in a corner AND not in parent mode AND not a button
                    currentSequenceIndex = 0;
                }

                if (!isParentModeActive) { // Only generate toddler feedback if not in parent mode
                    if (isTracingModeActive) {
                        startDrawing(event); // Start drawing on canvas if in tracing mode
                    } else {
                        generateVisualFeedback(touch.clientX, touch.clientY, 'tap');
                        changeBackgroundGradient();
                    }
                }
            }
        }

        // Event listener for touchmove (for swiping/dragging)
        let lastTouchMoveTime = 0;
        const touchMoveThrottle = 30;
        function handleTouchMove(event) {
            if (isLocked && isTouching && !isParentModeActive) { // Only generate if locked, touching, and not in parent mode
                event.preventDefault(); // Prevent default touch actions
                const currentTime = Date.now();
                if (isTracingModeActive) {
                    draw(event); // Draw on canvas if in tracing mode
                } else if (currentTime - lastTouchMoveTime > touchMoveThrottle) {
                    const touch = event.touches ? event.touches[0] : event; // Handle both touch and mousemove
                    generateVisualFeedback(touch.clientX, touch.clientY, 'swipe');
                    lastTouchMoveTime = currentTime;
                    if (Math.random() < 0.02) {
                        changeBackgroundGradient();
                    }
                }
            }
        }

        // Event listener for touchend (when finger is lifted)
        function handleTouchEnd(event) {
            if (isLocked) {
                isTouching = false;
                if (isTracingModeActive) {
                    stopDrawing(); // Stop drawing on canvas if in tracing mode
                }
            }
        }

        // --- Event Listeners for Parent Control Panel Buttons ---
        colorBtn.addEventListener('click', () => { showLessonPanel(colorLessonPanel); });
        shapeBtn.addEventListener('click', () => { showLessonPanel(shapeLessonPanel); });
        letterNumberBtn.addEventListener('click', () => { showLessonPanel(letterNumberLessonPanel); });
        freeplayBtn.addEventListener('click', () => {
            currentLessonMode = 'freeplay';
            console.log("Lesson Mode: Freeplay");
            deactivateParentMode(); // This correctly takes us back to freeplay
        });

        // --- Event Listeners for Lesson Specific Buttons ---
        colorPrimaryBtn.addEventListener('click', () => {
            currentLessonMode = 'color-primary';
            isTracingModeActive = false; // Ensure tracing is off for color lessons
            clearCanvas(); // Clear canvas if coming from tracing
            console.log("Lesson Mode: Color - Primary Colors");
            deactivateParentMode(); // This returns to toddler interaction
        });
        colorAllBtn.addEventListener('click', () => {
            currentLessonMode = 'color-all';
            isTracingModeActive = false; // Ensure tracing is off for color lessons
            clearCanvas(); // Clear canvas if coming from tracing
            console.log("Lesson Mode: Color - All Colors");
            deactivateParentMode(); // This returns to toddler interaction
        });
        colorBackBtn.addEventListener('click', () => { showLessonPanel(parentControlPanel); }); // Bottom Back to Parent Menu

        shapeBasicBtn.addEventListener('click', () => {
            currentLessonMode = 'shape-basic';
            isTracingModeActive = true; // Activate tracing for shapes
            console.log("Lesson Mode: Shape - Basic Shapes (Tracing)");
            deactivateParentMode(); // This returns to toddler interaction
            startNewTracingTarget(); // Start drawing the first shape for tracing
        });
        shapeAdvancedBtn.addEventListener('click', () => {
            currentLessonMode = 'shape-advanced';
            isTracingModeActive = true; // Activate tracing for shapes
            console.log("Lesson Mode: Shape - Advanced Shapes (Tracing)");
            deactivateParentMode(); // This returns to toddler interaction
            startNewTracingTarget(); // Start drawing the first shape for tracing
        });
        shapeBackBtn.addEventListener('click', () => {
            isTracingModeActive = false; // Deactivate tracing when going back to menu
            clearCanvas(); // Clear canvas
            showLessonPanel(parentControlPanel);
        });

        letterAZBtn.addEventListener('click', () => {
            currentLessonMode = 'letter-az';
            isTracingModeActive = true; // Activate tracing for letters
            console.log("Lesson Mode: Letter/Number - Letters (A-Z) (Tracing)");
            deactivateParentMode(); // This returns to toddler interaction
            startNewTracingTarget(); // Start drawing the first letter for tracing
        });
        number09Btn.addEventListener('click', () => {
            currentLessonMode = 'number-09';
            isTracingModeActive = true; // Activate tracing for numbers
            console.log("Lesson Mode: Letter/Number - Numbers (0-9) (Tracing)");
            deactivateParentMode(); // This returns to toddler interaction
            startNewTracingTarget(); // Start drawing the first number for tracing
        });
        letterNumberBackBtn.addEventListener('click', () => {
            isTracingModeActive = false; // Deactivate tracing when going back to menu
            clearCanvas(); // Clear canvas
            showLessonPanel(parentControlPanel);
        });

        // Event listener for the new "Back to Parent Menu" button visible during active lesson play
        backToParentMenuFromLessonBtn.addEventListener('click', returnToParentMenuFromLesson);


        // Function to lock the screen
        function lockScreen() {
            isLocked = true;
            lockOverlay.style.display = 'flex';
            body.classList.remove('unlocked');
            body.classList.add('locked');

            // Attach event listeners
            document.addEventListener('keydown', handleKeyDown);
            // Attach touch and mouse events to lockOverlay directly
            lockOverlay.addEventListener('touchstart', handleTouchStart, { passive: false });
            lockOverlay.addEventListener('touchmove', handleTouchMove, { passive: false });
            lockOverlay.addEventListener('touchend', handleTouchEnd);
            lockOverlay.addEventListener('mousemove', handleTouchMove); // Mousemove uses touchmove handler
            lockOverlay.addEventListener('click', handleTouchStart); // Click uses touchstart handler for now, as it also triggers the parent mode sequence logic

            // Initial state: show toddler messages, hide parent instruction and all panels, hide new back button
            showInitialMessages();
            parentModeInstruction.classList.add('hidden');
            hideAllLessonPanels(); // Ensure all panels are hidden
            hasInteracted = false; // Reset interaction flag
            backToParentMenuFromLessonBtn.classList.add('hidden'); // Ensure this is hidden initially

            // After initialMessageDuration, hide toddler messages and start parent instruction cycle
            setTimeout(() => {
                // Only transition if toddler hasn't interacted and parent mode isn't active
                // And only if we are in freeplay mode
                if (!hasInteracted && !isParentModeActive && currentLessonMode === 'freeplay') {
                    hideInitialMessages();
                    startParentInstructionTimer();
                }
            }, initialMessageDuration);

            deactivateParentMode(); // Ensure we start in toddler mode with instruction visible
            resizeCanvas(); // Set initial canvas size
            window.addEventListener('resize', resizeCanvas); // Resize canvas on window resize
        }

        // Function to unlock the screen
        function unlockScreen() {
            isLocked = false;
            lockOverlay.style.display = 'none';
            body.classList.remove('locked');
            body.classList.add('unlocked');

            // Remove event listeners from lockOverlay
            document.removeEventListener('keydown', handleKeyDown); // Keydown remains on document
            lockOverlay.removeEventListener('touchstart', handleTouchStart);
            lockOverlay.removeEventListener('touchmove', handleTouchMove);
            lockOverlay.removeEventListener('touchend', handleTouchEnd);
            lockOverlay.removeEventListener('mousemove', handleTouchMove);
            lockOverlay.removeEventListener('click', handleTouchStart);

            stopParentInstructionTimer(); // Stop instruction timer when unlocked
            deactivateParentMode(); // Ensure parent mode is off if unlocked
            window.removeEventListener('resize', resizeCanvas); // Remove resize listener
        }

        // Initialize the screen as locked when the page loads
        window.onload = lockScreen;

    </script>
</body>
</html>
ÔøΩ
