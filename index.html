<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Toddler Interactive Screen</title>
    <!-- Tailwind CSS CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js CDN for sound generation -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        /* Custom styles for the app */
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent scrolling */
            cursor: none; /* Hide default cursor when locked */
            touch-action: none; /* Prevent browser default touch actions like pull-to-refresh */
        }

        /* The main overlay that locks the screen */
        #lock-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            /* Initial subtle gradient, will be animated */
            background: radial-gradient(circle at center, #1a1a1a, #000000);
            background-size: 200% 200%; /* Larger background for animation */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 9999; /* Ensure it's on top of everything */
            transition: background 0.5s ease-in-out; /* Smooth background transitions for gradients */
            cursor: none; /* Hide cursor when locked */
            animation: background-flow 30s linear infinite alternate; /* Continuous, subtle background animation */
        }

        /* Keyframes for the continuous background flow */
        @keyframes background-flow {
            0% { background-position: 0% 0%; }
            100% { background-position: 100% 100%; }
        }

        /* Styles for the dynamically generated visual elements */
        .visual-element {
            position: absolute;
            opacity: 0;
            transform: scale(0.1) rotate(0deg); /* Initial state with rotation */
            transition: all 0.3s cubic-bezier(0.68, -0.55, 0.27, 1.55); /* Bouncy transition for appearance */
            pointer-events: none; /* Ensure these elements don't block events */
            user-select: none; /* Prevent text selection */
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
            will-change: transform, opacity; /* Optimize for animation */
        }

        /* Class to make the visual element appear */
        .visual-element.show {
            opacity: 1;
            transform: scale(1) rotate(var(--random-rotation, 0deg)); /* Use custom property for random rotation */
        }

        /* Class to fade out and remove the visual element, with added drift */
        .visual-element.hide {
            opacity: 0;
            transform: scale(1.5) rotate(var(--random-rotation, 0deg)) translate(var(--drift-x, 0px), var(--drift-y, 0px)); /* Slightly grow and drift as it fades */
            transition: all 0.7s ease-out; /* Longer transition for fade and drift */
        }

        /* Heartbeat animation for parent mode instruction */
        @keyframes pulse {
            0% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.05); opacity: 0.9; }
            100% { transform: scale(1); opacity: 1; }
        }

        .animate-heartbeat {
            animation: pulse 1.5s infinite;
        }

        /* Base styles for all parent panels */
        .parent-panel {
            position: absolute; /* Position relative to parent, not viewport */
            top: 50%; /* Center vertically */
            left: 50%; /* Center horizontally */
            transform: translate(-50%, -50%); /* Adjust for element's own size */
            background-color: rgba(51, 51, 51, 0.9); /* Dark gray, slightly transparent */
            padding: 2rem; /* More padding for centered look */
            display: flex;
            flex-direction: column; /* Stack buttons vertically */
            align-items: center; /* Center buttons horizontally within panel */
            gap: 1rem; /* More space between stacked buttons */
            z-index: 10000; /* Ensure it's on top */
            border-radius: 1rem; /* Rounded corners for the whole panel */
            box-shadow: 0 5px 20px rgba(0,0,0,0.5); /* Stronger shadow */
            opacity: 0; /* Start hidden */
            pointer-events: none; /* Do not block events when hidden */
            transition: opacity 0.3s ease-out; /* Fade in/out */
        }

        .parent-panel.show {
            opacity: 1; /* Fade in */
            pointer-events: auto; /* Allow interaction when shown */
        }

        /* Specific styling for the main parent control panel (no background color) */
        #parent-control-panel {
            background-color: transparent; /* Make background transparent */
            box-shadow: none; /* Remove shadow if background is transparent */
            padding: 0; /* Remove padding if background is transparent */
            gap: 0.75rem; /* Slightly smaller gap for main menu */
        }

        /* Styling for buttons within all parent panels */
        .parent-panel button {
            @apply flex-grow md:flex-grow-0 px-4 py-2 rounded-lg font-bold shadow-md transition-all duration-200;
            min-width: 180px; /* Ensure buttons have a minimum width for readability */
            background-color: rgba(74, 74, 74, 0.8); /* Darker gray to match theme, slightly transparent */
            border: 2px solid #6A0572; /* Purple border */
            color: #D14081; /* Vibrant purple text */
            cursor: pointer;
        }

        .parent-panel button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.4);
            background-color: rgba(102, 102, 102, 0.8); /* Slightly lighter gray on hover */
            border-color: #F08A5D; /* Orange border on hover */
            color: #FFD166; /* Yellow text on hover */
        }

        /* Specific styling for "Back to Parent Menu" button */
        .back-button {
            background-color: rgba(40, 40, 40, 0.8) !important; /* Even darker gray */
            border-color: #118AB2 !important; /* Blue border */
            color: #06D6A0 !important; /* Green text */
        }

        .back-button:hover {
            background-color: rgba(60, 60, 60, 0.8) !important;
            border-color: #2EC4B6 !important; /* Lighter blue border */
            color: #FFD166 !important; /* Yellow text on hover */
        }
    </style>
</head>
<body class="locked">
    <!-- The main overlay that covers the entire screen when locked -->
    <div id="lock-overlay" class="rounded-lg">
        <!-- Initial messages (shown first) -->
        <h1 id="main-title" class="text-white text-5xl md:text-7xl font-extrabold mb-8 text-center animate-pulse">
            Ready to Play!
        </h1>
        <p id="main-message" class="text-white text-xl md:text-2xl text-center">
            Tap or swipe the screen!
        </p>
        <!-- Parent Mode Activation Instruction (initially hidden) -->
        <p id="parent-mode-instruction" class="text-white text-xl md:text-2xl text-center animate-heartbeat hidden">
            Tap all four corners clockwise to activate Parent Mode
        </p>
        <!-- This area will be dynamically populated with visual feedback -->
        <div id="visual-feedback-area"></div>
    </div>

    <!-- Main Parent Control Panel -->
    <div id="parent-control-panel" class="parent-panel hidden">
        <button id="color-recognition-btn">Color Recognition</button>
        <button id="shape-recognition-btn">Shape Recognition</button>
        <button id="letter-number-btn">Letter/Number Introduction</button>
        <button id="object-animal-btn">Object/Animal Vocabulary</button>
        <button id="freeplay-btn">Back to Freeplay</button>
    </div>

    <!-- Lesson Specific Panels (initially hidden) -->
    <div id="color-lesson-panel" class="parent-panel hidden">
        <button id="color-primary-btn">Primary Colors</button>
        <button id="color-all-btn">All Colors</button>
        <button class="back-button" id="color-back-btn">Back to Parent Menu</button>
    </div>

    <div id="shape-lesson-panel" class="parent-panel hidden">
        <button id="shape-basic-btn">Basic Shapes</button>
        <button id="shape-advanced-btn">Advanced Shapes</button>
        <button class="back-button" id="shape-back-btn">Back to Parent Menu</button>
    </div>

    <div id="letter-number-lesson-panel" class="parent-panel hidden">
        <button id="letter-az-btn">Letters (A-Z)</button>
        <button id="number-09-btn">Numbers (0-9)</button>
        <button class="back-button" id="letter-number-back-btn">Back to Parent Menu</button>
    </div>

    <div id="object-animal-lesson-panel" class="parent-panel hidden">
        <button id="object-animal-btn-animals">Animals</button>
        <button id="object-animal-btn-objects">Objects/Vehicles</button>
        <button class="back-button" id="object-animal-back-btn">Back to Parent Menu</button>
    </div>

    <script>
        // Get references to the main elements
        const lockOverlay = document.getElementById('lock-overlay');
        const visualFeedbackArea = document.getElementById('visual-feedback-area');
        const mainTitle = document.getElementById('main-title');
        const mainMessage = document.getElementById('main-message');
        const parentModeInstruction = document.getElementById('parent-mode-instruction');
        const parentControlPanel = document.getElementById('parent-control-panel');

        // Get references to parent mode buttons
        const colorBtn = document.getElementById('color-recognition-btn');
        const shapeBtn = document.getElementById('shape-recognition-btn');
        const letterNumberBtn = document.getElementById('letter-number-btn');
        const objectAnimalBtn = document.getElementById('object-animal-btn'); // This ID is reused, will need to fix.
        const freeplayBtn = document.getElementById('freeplay-btn');

        // Get references to lesson specific panels and their buttons
        const colorLessonPanel = document.getElementById('color-lesson-panel');
        const colorPrimaryBtn = document.getElementById('color-primary-btn');
        const colorAllBtn = document.getElementById('color-all-btn');
        const colorBackBtn = document.getElementById('color-back-btn');

        const shapeLessonPanel = document.getElementById('shape-lesson-panel');
        const shapeBasicBtn = document.getElementById('shape-basic-btn');
        const shapeAdvancedBtn = document.getElementById('shape-advanced-btn');
        const shapeBackBtn = document.getElementById('shape-back-btn');

        const letterNumberLessonPanel = document.getElementById('letter-number-lesson-panel');
        const letterAZBtn = document.getElementById('letter-az-btn');
        const number09Btn = document.getElementById('number-09-btn');
        const letterNumberBackBtn = document.getElementById('letter-number-back-btn');

        const objectAnimalLessonPanel = document.getElementById('object-animal-lesson-panel');
        const objectAnimalBtnAnimals = document.getElementById('object-animal-btn-animals'); // Corrected ID
        const objectAnimalBtnObjects = document.getElementById('object-animal-btn-objects'); // Corrected ID
        const objectAnimalBackBtn = document.getElementById('object-animal-back-btn');


        const body = document.body;

        // State variables
        let isLocked = true;
        let isTouching = false;
        let hasInteracted = false; // Tracks if toddler has started interacting
        let isParentModeActive = false; // New flag for parent mode
        let currentLessonMode = 'freeplay'; // Default lesson mode
        let audioContextStarted = false; // Flag to track if Tone.js audio context has started

        // Parent Mode Activation Sequence
        const parentModeSequence = ['top-left', 'top-right', 'bottom-right', 'bottom-left'];
        let currentSequenceIndex = 0;
        let lastTapTime = 0;
        const tapTimeout = 2000; // 2 seconds to complete next tap in sequence

        // Timer for parent mode instruction visibility
        let parentInstructionTimer;
        const initialMessageDuration = 7000; // 7 seconds for initial "Ready to Play" messages
        const instructionShowDuration = 7000; // 7 seconds for parent mode instruction
        const instructionHideDuration = 30000; // 30 seconds for parent mode instruction

        // Initialize Tone.js Synth for sound feedback
        const synth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: "sine" },
            envelope: { attack: 0.01, decay: 0.1, sustain: 0.05, release: 0.3 },
            volume: -20
        }).toDestination();

        // Array of vibrant colors for visual feedback and background gradients
        const colors = [
            '#FF6B6B', '#FFD166', '#06D6A0', '#118AB2', '#073B4C',
            '#FF9F1C', '#2EC4B6', '#E71D36', '#F7B801', '#A9F0D1',
            '#C70039', '#FFC300', '#DAF7A6', '#FF5733', '#C70039',
            '#6A0572', '#AB83A1', '#8E292E', '#D14081', '#F08A5D'
        ];

        // Specific colors for 'color-recognition' lesson
        const lessonColorsPrimary = ['#FF0000', '#0000FF', '#00FF00']; // Red, Blue, Green
        const lessonColorsAll = ['#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF', '#FF6B6B', '#FFD166', '#06D6A0', '#118AB2']; // Expanded set

        // Specific shapes for 'shape-recognition' lesson
        const lessonShapesBasic = ['â—', 'â– ', 'â–²']; // Circle, Square, Triangle
        const lessonShapesAdvanced = ['â˜…', 'â—†', 'â¤', 'â­']; // Star, Diamond, Heart, Sparkle Star

        // Characters for 'letter-number-introduction' lesson (A-Z, 0-9)
        const lessonLetters = [
            'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',
            'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'
        ];
        const lessonNumbers = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];

        // Emojis for 'object-animal-vocabulary' lesson
        const lessonEmojisAnimals = ['ðŸ¸', 'ðŸ¢', 'ðŸ¥', 'ðŸ ', 'ðŸ¦‹', 'ðŸ¾'];
        const lessonEmojisObjects = ['ðŸš—', 'ðŸš‚', 'ðŸš', 'ðŸš²', 'ðŸ§¸', 'âš½', 'ðŸŽ¨', 'ðŸ§©', 'ðŸ‘‘', 'ðŸ„', 'ðŸŽ', 'ðŸŠ', 'ðŸ‹', 'ðŸ‰', 'ðŸ‡', 'ðŸ“'];

        // All characters/emojis for freeplay
        const characters = [
            ...lessonLetters, ...lessonNumbers, ...lessonEmojisAnimals, ...lessonEmojisObjects,
            'â­', 'ðŸŒˆ', 'ðŸŽ‰', 'ðŸŽˆ', 'âœ¨', 'ðŸš€', 'ðŸ’–', 'ðŸ’¡', 'ðŸŽµ', 'ðŸŒ¸', 'ðŸŒ³', 'â˜€ï¸', 'ðŸŒ™', 'â˜ï¸'
        ];

        // Array of musical notes for sound feedback
        const notes = ['C4', 'D4', 'E4', 'G4', 'A4', 'C5', 'D5', 'E5'];

        // Function to get a random element from an array
        function getRandomElement(arr) {
            return arr[Math.floor(Math.random() * arr.length)];
        }

        // Function to hide the initial messages (Ready to Play / Tap or swipe)
        function hideInitialMessages() {
            if (mainTitle) mainTitle.classList.add('hidden');
            if (mainMessage) mainMessage.classList.add('hidden');
        }

        // Function to show the initial messages
        function showInitialMessages() {
            if (mainTitle) mainTitle.classList.remove('hidden');
            if (mainMessage) mainMessage.classList.remove('hidden');
        }

        // Function to manage parent mode instruction visibility
        function startParentInstructionTimer() {
            // Clear any existing timer
            if (parentInstructionTimer) clearInterval(parentInstructionTimer);

            function showAndHideParentInstruction() {
                parentModeInstruction.classList.remove('hidden');
                parentModeInstruction.classList.add('animate-heartbeat'); // Ensure animation is active
                setTimeout(() => {
                    parentModeInstruction.classList.add('hidden');
                    parentModeInstruction.classList.remove('animate-heartbeat'); // Remove animation when hidden
                }, instructionShowDuration);
            }

            // Show immediately, then set interval for repeated show/hide
            showAndHideParentInstruction();
            parentInstructionTimer = setInterval(showAndHideParentInstruction, instructionHideDuration + instructionShowDuration);
        }

        function stopParentInstructionTimer() {
            if (parentInstructionTimer) {
                clearInterval(parentInstructionTimer);
                parentInstructionTimer = null;
            }
            parentModeInstruction.classList.add('hidden');
            parentModeInstruction.classList.remove('animate-heartbeat');
        }

        // Function to get the corner based on coordinates
        function getCorner(x, y) {
            const width = window.innerWidth;
            const height = window.innerHeight;
            const cornerThreshold = 0.2; // 20% of screen width/height for corner detection

            if (x < width * cornerThreshold && y < height * cornerThreshold) {
                return 'top-left';
            } else if (x > width * (1 - cornerThreshold) && y < height * cornerThreshold) {
                return 'top-right';
            } else if (x > width * (1 - cornerThreshold) && y > height * (1 - cornerThreshold)) {
                return 'bottom-right';
            } else if (x < width * cornerThreshold && y > height * (1 - cornerThreshold)) {
                return 'bottom-left';
            }
            return null; // Not in a defined corner
        }

        // Function to hide all lesson panels
        function hideAllLessonPanels() {
            const panels = [parentControlPanel, colorLessonPanel, shapeLessonPanel, letterNumberLessonPanel, objectAnimalLessonPanel];
            panels.forEach(panel => {
                panel.classList.remove('show');
                panel.classList.add('hidden');
            });
        }

        // Function to show a specific lesson panel
        function showLessonPanel(panelElement) {
            hideAllLessonPanels(); // Hide all others first
            panelElement.classList.remove('hidden');
            setTimeout(() => {
                panelElement.classList.add('show');
            }, 10);
        }

        // Function to activate parent mode (show main parent menu)
        function activateParentMode() {
            isParentModeActive = true;
            stopParentInstructionTimer();
            parentModeInstruction.classList.add('hidden');
            hideInitialMessages(); // Ensure initial messages are hidden if parent mode is activated early

            showLessonPanel(parentControlPanel); // Show the main parent control panel

            console.log("Parent Mode Activated!");
            // Change background to indicate parent mode
            lockOverlay.style.background = `radial-gradient(circle at center, #333333, #111111)`; // Subtle gray
            lockOverlay.style.animation = 'none'; // Stop background flow animation
            lockOverlay.style.backgroundSize = 'cover'; // Reset background size for static color
        }

        // Function to deactivate parent mode (return to toddler freeplay)
        function deactivateParentMode() {
            isParentModeActive = false;
            currentSequenceIndex = 0; // Reset sequence
            lastTapTime = 0; // Reset tap time
            stopParentInstructionTimer(); // Ensure it's stopped before starting new sequence

            hideAllLessonPanels(); // Hide all parent/lesson panels

            // Reset background to dynamic
            lockOverlay.style.animation = 'background-flow 30s linear infinite alternate';
            lockOverlay.style.backgroundSize = '200% 200%';
            changeBackgroundGradient(); // Set an initial dynamic gradient
            hasInteracted = false; // Reset interaction flag so initial messages can show again on re-lock
        }

        // Function to generate and display visual feedback
        async function generateVisualFeedback(x, y, type, content = '') {
            // Ensure audio context is started on first interaction
            if (!audioContextStarted) {
                await Tone.start();
                audioContextStarted = true;
                console.log("AudioContext started:", Tone.context.state);
            }

            if (!isLocked || isParentModeActive) return; // Only generate feedback when locked AND not in parent mode

            // Hide initial messages on first interaction
            if (!hasInteracted) {
                hideInitialMessages();
                // Ensure parent mode instruction starts its cycle only after initial messages are gone
                startParentInstructionTimer();
                hasInteracted = true;
            }

            const visualElement = document.createElement('div');
            visualElement.classList.add('visual-element');
            visualElement.style.left = `${x}px`;
            visualElement.style.top = `${y}px`;

            const randomRotation = Math.random() * 360 - 180;
            visualElement.style.setProperty('--random-rotation', `${randomRotation}deg`);

            const driftX = (Math.random() - 0.5) * 100;
            const driftY = (Math.random() - 0.5) * 100;
            visualElement.style.setProperty('--drift-x', `${driftX}px`);
            visualElement.style.setProperty('--drift-y', `${driftY}px`);

            // --- Lesson-specific content generation ---
            let elementContent = '';
            let elementColor = getRandomElement(colors); // Default random color

            if (type === 'tap') {
                if (currentLessonMode === 'color-primary') {
                    elementColor = getRandomElement(lessonColorsPrimary);
                    elementContent = getRandomElement(lessonShapesBasic); // Use basic shapes for color lesson
                    visualElement.style.fontSize = `${Math.random() * 60 + 40}px`;
                } else if (currentLessonMode === 'color-all') {
                    elementColor = getRandomElement(lessonColorsAll);
                    elementContent = getRandomElement(lessonShapesBasic); // Use basic shapes for color lesson
                    visualElement.style.fontSize = `${Math.random() * 60 + 40}px`;
                } else if (currentLessonMode === 'shape-basic') {
                    elementContent = getRandomElement(lessonShapesBasic);
                    elementColor = getRandomElement(colors); // Random color for shapes
                    visualElement.style.fontSize = `${Math.random() * 60 + 40}px`;
                } else if (currentLessonMode === 'shape-advanced') {
                    elementContent = getRandomElement(lessonShapesAdvanced);
                    elementColor = getRandomElement(colors); // Random color for shapes
                    visualElement.style.fontSize = `${Math.random() * 60 + 40}px`;
                } else if (currentLessonMode === 'letter-az') {
                    elementContent = getRandomElement(lessonLetters);
                    elementColor = getRandomElement(colors); // Random color for letters
                    visualElement.style.fontSize = `${Math.random() * 60 + 40}px`;
                } else if (currentLessonMode === 'number-09') {
                    elementContent = getRandomElement(lessonNumbers);
                    elementColor = getRandomElement(colors); // Random color for numbers
                    visualElement.style.fontSize = `${Math.random() * 60 + 40}px`;
                } else if (currentLessonMode === 'object-animal-animals') {
                    elementContent = getRandomElement(lessonEmojisAnimals);
                    elementColor = getRandomElement(colors); // Random color for animal emojis
                    visualElement.style.fontSize = `${Math.random() * 60 + 40}px`;
                } else if (currentLessonMode === 'object-animal-objects') {
                    elementContent = getRandomElement(lessonEmojisObjects);
                    elementColor = getRandomElement(colors); // Random color for object emojis
                    visualElement.style.fontSize = `${Math.random() * 60 + 40}px`;
                } else { // 'freeplay' or default
                    let sourceArray = characters;
                    if (typeof characters === 'undefined' || !Array.isArray(characters) || characters.length === 0) {
                        console.warn("Characters array is undefined, not an array, or empty. Falling back to default.");
                        sourceArray = ['?', '!', '@']; // Fallback content
                    }
                    elementContent = getRandomElement(sourceArray);
                    elementColor = getRandomElement(colors); // Random color
                    visualElement.style.fontSize = `${Math.random() * 60 + 40}px`;
                }
            } else if (type === 'swipe') {
                elementContent = getRandomElement(['âœ¨', 'ðŸ’¥', 'ðŸŒˆ', 'ðŸŒŸ', 'ðŸ’§', 'ðŸ’«', 'ðŸ’–', 'ðŸ’¡']);
                elementColor = getRandomElement(colors); // Random color for swipe effects
                visualElement.style.fontSize = `${Math.random() * 30 + 20}px`;
            }

            visualElement.textContent = elementContent;
            visualElement.style.color = elementColor;

            visualFeedbackArea.appendChild(visualElement);

            setTimeout(() => {
                visualElement.classList.add('show');
            }, 10);

            synth.triggerAttackRelease(getRandomElement(notes), '8n');

            setTimeout(() => {
                visualElement.classList.remove('show');
                visualElement.classList.add('hide');
                visualElement.addEventListener('transitionend', () => {
                    visualElement.remove();
                });
            }, 700);
        }

        // Function to change the background to a random radial gradient (on tap/key)
        function changeBackgroundGradient() {
            if (!isLocked || isParentModeActive) return; // Only change background when locked AND not in parent mode
            const color1 = getRandomElement(colors);
            const color2 = getRandomElement(colors);
            lockOverlay.style.background = `radial-gradient(circle at center, ${color1}, ${color2})`;
            lockOverlay.style.backgroundSize = '200% 200%';
        }

        // Event listener for keydown events (for physical keyboards/hybrid devices)
        async function handleKeyDown(event) {
            // Ensure audio context is started on first interaction
            if (!audioContextStarted) {
                await Tone.start();
                audioContextStarted = true;
                console.log("AudioContext started:", Tone.context.state);
            }

            if (isLocked) {
                event.preventDefault();

                // Check for unlock combination: Ctrl + Shift + L
                if (event.ctrlKey && event.shiftKey && event.key === 'L') {
                    unlockScreen();
                } else if (!isParentModeActive) { // Only generate toddler feedback if not in parent mode
                    const x = Math.random() * window.innerWidth;
                    const y = Math.random() * window.innerHeight;
                    generateVisualFeedback(x, y, 'tap', event.key.toUpperCase());
                    changeBackgroundGradient();
                }
            }
        }

        // Event listener for touchstart (for initial tap)
        async function handleTouchStart(event) {
            // Ensure audio context is started on first interaction
            if (!audioContextStarted) {
                await Tone.start();
                audioContextStarted = true;
                console.log("AudioContext started:", Tone.context.state);
            }

            if (isLocked) {
                event.preventDefault();
                isTouching = true;

                const touch = event.touches ? event.touches[0] : event; // Handle both touch and click events
                const tappedCorner = getCorner(touch.clientX, touch.clientY);
                const currentTime = Date.now();

                // Parent Mode Activation Logic
                // Only check sequence if not already in parent mode and tapped a corner
                // Also, ensure we are not tapping on a button within a parent panel
                const targetIsButton = event.target.tagName === 'BUTTON';
                if (!isParentModeActive && tappedCorner && !targetIsButton) {
                    if (currentTime - lastTapTime > tapTimeout) {
                        currentSequenceIndex = 0; // Reset sequence if too much time passed
                    }

                    if (tappedCorner === parentModeSequence[currentSequenceIndex]) {
                        currentSequenceIndex++;
                        if (currentSequenceIndex === parentModeSequence.length) {
                            activateParentMode();
                            currentSequenceIndex = 0; // Reset for next time
                        }
                    } else {
                        currentSequenceIndex = 0; // Reset if wrong corner
                    }
                    lastTapTime = currentTime;
                } else if (!isParentModeActive && !targetIsButton) { // Reset sequence if tap is not in a corner AND not in parent mode AND not a button
                    currentSequenceIndex = 0;
                }

                if (!isParentModeActive) { // Only generate toddler feedback if not in parent mode
                    generateVisualFeedback(touch.clientX, touch.clientY, 'tap');
                    changeBackgroundGradient();
                }
            }
        }

        // Event listener for touchmove (for swiping/dragging)
        let lastTouchMoveTime = 0;
        const touchMoveThrottle = 30;
        function handleTouchMove(event) {
            if (isLocked && isTouching && !isParentModeActive) { // Only generate if locked, touching, and not in parent mode
                event.preventDefault();
                const currentTime = Date.now();
                if (currentTime - lastTouchMoveTime > touchMoveThrottle) {
                    const touch = event.touches ? event.touches[0] : event; // Handle both touch and mousemove
                    generateVisualFeedback(touch.clientX, touch.clientY, 'swipe');
                    lastTouchMoveTime = currentTime;
                    if (Math.random() < 0.02) {
                        changeBackgroundGradient();
                    }
                }
            }
        }

        // Event listener for touchend (when finger is lifted)
        function handleTouchEnd(event) {
            if (isLocked) {
                isTouching = false;
            }
        }

        // --- Event Listeners for Parent Control Panel Buttons ---
        colorBtn.addEventListener('click', () => { showLessonPanel(colorLessonPanel); });
        shapeBtn.addEventListener('click', () => { showLessonPanel(shapeLessonPanel); });
        letterNumberBtn.addEventListener('click', () => { showLessonPanel(letterNumberLessonPanel); });
        objectAnimalBtn.addEventListener('click', () => { showLessonPanel(objectAnimalLessonPanel); }); // This was the main button, now it's a specific one.
        freeplayBtn.addEventListener('click', () => {
            currentLessonMode = 'freeplay';
            console.log("Lesson Mode: Freeplay");
            deactivateParentMode();
        });

        // --- Event Listeners for Lesson Specific Buttons ---
        colorPrimaryBtn.addEventListener('click', () => {
            currentLessonMode = 'color-primary';
            console.log("Lesson Mode: Color - Primary Colors");
            deactivateParentMode();
        });
        colorAllBtn.addEventListener('click', () => {
            currentLessonMode = 'color-all';
            console.log("Lesson Mode: Color - All Colors");
            deactivateParentMode();
        });
        colorBackBtn.addEventListener('click', () => { showLessonPanel(parentControlPanel); });

        shapeBasicBtn.addEventListener('click', () => {
            currentLessonMode = 'shape-basic';
            console.log("Lesson Mode: Shape - Basic Shapes");
            deactivateParentMode();
        });
        shapeAdvancedBtn.addEventListener('click', () => {
            currentLessonMode = 'shape-advanced';
            console.log("Lesson Mode: Shape - Advanced Shapes");
            deactivateParentMode();
        });
        shapeBackBtn.addEventListener('click', () => { showLessonPanel(parentControlPanel); });

        letterAZBtn.addEventListener('click', () => {
            currentLessonMode = 'letter-az';
            console.log("Lesson Mode: Letter/Number - Letters (A-Z)");
            deactivateParentMode();
        });
        number09Btn.addEventListener('click', () => {
            currentLessonMode = 'number-09';
            console.log("Lesson Mode: Letter/Number - Numbers (0-9)");
            deactivateParentMode();
        });
        letterNumberBackBtn.addEventListener('click', () => { showLessonPanel(parentControlPanel); });

        objectAnimalBtnAnimals.addEventListener('click', () => {
            currentLessonMode = 'object-animal-animals';
            console.log("Lesson Mode: Object/Animal - Animals");
            deactivateParentMode();
        });
        objectAnimalBtnObjects.addEventListener('click', () => {
            currentLessonMode = 'object-animal-objects';
            console.log("Lesson Mode: Object/Animal - Objects/Vehicles");
            deactivateParentMode();
        });
        objectAnimalBackBtn.addEventListener('click', () => { showLessonPanel(parentControlPanel); });


        // Function to lock the screen
        function lockScreen() {
            isLocked = true;
            lockOverlay.style.display = 'flex';
            body.classList.remove('unlocked');
            body.classList.add('locked');

            // Attach event listeners
            document.addEventListener('keydown', handleKeyDown);
            document.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd);
            document.addEventListener('mousemove', handleTouchMove); // Mousemove uses touchmove handler
            document.addEventListener('click', handleTouchStart); // Click uses touchstart handler

            // Initial state: show toddler messages, hide parent instruction and all panels
            showInitialMessages();
            parentModeInstruction.classList.add('hidden');
            hideAllLessonPanels(); // Ensure all panels are hidden
            hasInteracted = false; // Reset interaction flag

            // After initialMessageDuration, hide toddler messages and start parent instruction cycle
            setTimeout(() => {
                // Only transition if toddler hasn't interacted and parent mode isn't active
                if (!hasInteracted && !isParentModeActive) {
                    hideInitialMessages();
                    startParentInstructionTimer();
                }
            }, initialMessageDuration);

            deactivateParentMode(); // Ensure we start in toddler mode with instruction visible
        }

        // Function to unlock the screen
        function unlockScreen() {
            isLocked = false;
            lockOverlay.style.display = 'none';
            body.classList.remove('locked');
            body.classList.add('unlocked');

            // Remove event listeners
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('touchstart', handleTouchStart);
            document.removeEventListener('touchmove', handleTouchMove);
            document.removeEventListener('touchend', handleTouchEnd);
            document.removeEventListener('mousemove', handleTouchMove);
            document.removeEventListener('click', handleTouchStart);

            stopParentInstructionTimer(); // Stop instruction timer when unlocked
            deactivateParentMode(); // Ensure parent mode is off if unlocked
        }

        // Initialize the screen as locked when the page loads
        window.onload = lockScreen;

    </script>
</body>
</html>
